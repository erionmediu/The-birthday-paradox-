num_cores <- detectCores() - 1
cluster <- makeCluster(num_cores)
# Export necessary objects to the cluster
clusterExport(cluster, varlist = c("run_simulation", "data_sample", "count_shared_birthday"))
library(parallel)
run_simulation <- function(group_size, min_shared, data_sample, num_simulations = 10000) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- sum(replicate(num_simulations, {
sampled_birthdays <- sample(data_sample, group_size, replace = TRUE)
count_shared_birthday(min_shared, sampled_birthdays)
}))
successful_simulations / num_simulations
}
# Prepare data sample
data_sample <- data$birthday
# Set up a parallel cluster
num_cores <- detectCores() - 1
cluster <- makeCluster(num_cores)
# Export necessary objects to the cluster
clusterExport(cluster, varlist = c("run_simulation", "data_sample", "count_shared_birthday"))
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
library(parallel)
run_simulation <- function(group_size, min_shared, data_sample, num_simulations = 10000) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- sum(replicate(num_simulations, {
sampled_birthdays <- sample(data_sample, group_size, replace = TRUE)
count_shared_birthday(min_shared, sampled_birthdays)
}))
successful_simulations / num_simulations
}
# Prepare data sample
data_sample <- data$birthday
# Set up a parallel cluster
num_cores <- detectCores() - 1
cluster <- makeCluster(num_cores)
# Export necessary objects to the cluster
clusterExport(cluster, varlist = c("run_simulation", "data_sample", "count_shared_birthday"))
# Run the simulation in parallel
group_sizes <- 2:50
min_shared_values <- 3:length(group_sizes)
results <- parLapply(cluster, group_sizes, function(size) {
run_simulation(size, 2, data_sample)
})
### Calculating probabilities ----
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
successful_simulations / num_simulations
}
# Run the simulation for group sizes 2 to 50 and for minimum shared of 3 to all
group_sizes <- 2:50
min_shared_values <- 3:length(group_sizes)  # Adjust this based on your need
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
print(i)
}
successful_simulations / num_simulations
}
# Run the simulation for group sizes 2 to 50 and for minimum shared of 3 to all
group_sizes <- 2:50
min_shared_values <- 3:length(group_sizes)  # Adjust this based on your need
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
print(i)
}
successful_simulations / num_simulations
}
# Run the simulation for group sizes 2 to 50 and for minimum shared of 3 to all
group_sizes <- 2:5
min_shared_values <- 3:length(group_sizes)  # Adjust this based on your need
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
# Show the results
print(results)
### Calculating probabilities ----
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
print(i)
}
probability = successful_simulations / num_simulations
return(probability)
}
# Run the simulation for group sizes 2 to 50 and for minimum shared of 3 to all
group_sizes <- 2:5
min_shared_values <- 3:length(group_sizes)  # Adjust this based on your need
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
# Show the results
print(results)
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
print(i)
}
probability = successful_simulations / num_simulations
return(probability)
}
# Run the simulation for group sizes 2 to 50 and for minimum shared of 3 to all
group_sizes <- 100:103
min_shared_values <- 100:length(group_sizes)  # Adjust this based on your need
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
# Show the results
print(results)
group_size = 100
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
print(i)
}
probability = successful_simulations / num_simulations
return(probability)
}
run_simulation(data, group_size, num_simulations = 100, min_shared = 2)
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
run_simulation(data, group_size, num_simulations = 100, min_shared = 2)
run_simulation(data, group_size, num_simulations = 100, min_shared = 10)
run_simulation(data, group_size, num_simulations = 100, min_shared = 1)
run_simulation(data, group_size, num_simulations = 100, min_shared = 3)
run_simulation(data, group_size, num_simulations = 100, min_shared = 4)
run_simulation(data, group_size, num_simulations = 100, min_shared = 2)
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Define a range of group sizes
group_sizes <- 2:50  # Modify this as needed
# Store probabilities for each group size
probabilities <- sapply(group_sizes, function(size) {
run_simulation(data, size, num_simulations = 100, min_shared = 2)
})
# Combine group sizes with their probabilities
results <- data.frame(Group_Size = group_sizes, Probability = probabilities)
# View the results
print(results)
run_simulation <- function(data, group_size, num_simulations = 100, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Define a range of group sizes
group_sizes <- 2:50  # Modify this as needed
# Store probabilities for each group size
probabilities <- sapply(group_sizes, function(size) {
run_simulation(data, size, num_simulations = 1000, min_shared = 2)
})
# Combine group sizes with their probabilities
results <- data.frame(Group_Size = group_sizes, Probability = probabilities)
# View the results
print(results)
run_simulation <- function(data, group_size, num_simulations = 1000, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Define a range of group sizes and min_shared values
group_sizes <- 55:60  # Modify this as needed
min_shared_values <- 2:5  # From 2 to 10 identical birthdays
# Store probabilities for each combination of group size and min_shared
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
# Reshape results for better readability
library(reshape2)
results_wide <- dcast(results, Group_Size ~ Min_Shared, value.var = "Probability")
names(results_wide)[-1] <- paste0("prob", 2:10)
# View the results
print(results_wide)
names(results_wide)[-1] <- paste0("prob", 2:10)
names(results_wide)
names(results_wide)[-1]
paste0("prob", 2:10)
names(results_wide)[-1] <- paste0("prob", 2:5)
# View the results
print(results_wide)
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared = 2) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Define a range of group sizes and min_shared values
group_sizes <- 10:1000  # Modify this as needed
min_shared_values <- 2:5  # From 2 to 10 identical birthdays
# Store probabilities for each combination of group size and min_shared
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Prepare data sample
data_sample <- data$birthday
# Set up parallel cluster
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
# Export necessary objects to the cluster
clusterExport(cl, varlist = c("run_simulation", "data_sample", "count_shared_birthday"))
# Define range of group sizes and min_shared values
group_sizes <- 10:100
min_shared_values <- 2:5
# Create combinations of group sizes and min_shared values
combinations <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
# Run the simulations in parallel
results <- parLapply(cl, seq(nrow(combinations)), function(i) {
run_simulation(combinations$Group_Size[i], combinations$Min_Shared[i], data_sample)
})
# Create combinations of group sizes and min_shared values
combinations <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
# Run the simulations in parallel
results <- parLapply(cl, seq(nrow(combinations)), function(i) {
run_simulation(combinations$Group_Size[i], combinations$Min_Shared[i], data_sample)
})
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Prepare data sample
data_sample <- data$birthday
# Set up parallel cluster
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
# Export necessary objects to the cluster
clusterExport(cl, varlist = c("run_simulation", "data_sample", "count_shared_birthday"))
# Define range of group sizes and min_shared values
group_sizes <- 10:100
min_shared_values <- 2:5
# Create combinations of group sizes and min_shared values
combinations <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
# Run the simulations in parallel
results <- parLapply(cl, seq(nrow(combinations)), function(i) {
run_simulation(combinations$Group_Size[i], combinations$Min_Shared[i], data_sample)
})
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Prepare data sample
data_sample <- data$birthday
# Set up parallel cluster
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
# Create combinations of group sizes and min_shared values
combinations <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
# Export necessary objects to the cluster
clusterExport(cl, varlist = c("run_simulation", "data_sample", "count_shared_birthday", "combinations"))
# Run the simulations in parallel
results <- parLapply(cl, seq(nrow(combinations)), function(i) {
run_simulation(combinations$Group_Size[i], combinations$Min_Shared[i], data_sample, num_simulations = 10000)
})
View(combinations)
seq(nrow(combinations))
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Define a range of group sizes and min_shared values
group_sizes <- 23:50  # Modify this as needed
min_shared_values <- 2:5  # From 2 to 10 identical birthdays
# Store probabilities for each combination of group size and min_shared
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
sd
ds
as.data.frame()
stop
run_simulation <- function(data, group_size, num_simulations = 10000, min_shared) {
count_shared_birthday <- function(min_shared, birthdays) {
any(table(birthdays) >= min_shared)
}
successful_simulations <- 0
for (i in 1:num_simulations) {
sampled_birthdays <- sample(data$birthday, group_size, replace = TRUE)
if (count_shared_birthday(min_shared, sampled_birthdays)) {
successful_simulations <- successful_simulations + 1
}
}
probability = successful_simulations / num_simulations
return(probability)
}
# Define a range of group sizes and min_shared values
group_sizes <- 23:50  # Modify this as needed
min_shared_values <- 2:5  # From 2 to 10 identical birthdays
# Store probabilities for each combination of group size and min_shared
results <- expand.grid(Group_Size = group_sizes, Min_Shared = min_shared_values)
results$Probability <- mapply(run_simulation, data = list(data),
group_size = results$Group_Size,
min_shared = results$Min_Shared)
rm(list = ls())
filepath = rstudioapi::getSourceEditorContext()$path
dirpath = dirname(rstudioapi::getSourceEditorContext()$path)
setwd(dirpath)
dirpath
if (!("dplyr" %in% installed.packages())) {
install.packages("dplyr")
}
library(dplyr)
if (!("lubridate" %in% installed.packages())) {
install.packages("lubridate")
}
library(lubridate)
library(ggplot2)
data1= read.csv(file = 'Basic_Stats.csv')
data2= read.csv('congress-terms.csv')
prep_pipeline <- function(data1, data2) {
# Convert column names to lowercase
names(data1) <- tolower(names(data1))
names(data2) <- tolower(names(data2))
data1$birthday = dmy(data1$birthday)
data2$birthday = ymd(data2$birthday)
# failed to parse = symbolize NA data points
# Select 'birthday' column if it exists
if ('birthday' %in% names(data1)) {
data1 <- data1 %>% select(birthday)
} else {
stop('No birthday column found in data1')
}
if ('birthday' %in% names(data2)) {
data2 <- data2 %>% select(birthday)
} else {
stop('No birthday column found in data2')
}
# Merge the datasets row-wise
merged_data <- bind_rows(data1, data2)
# Remove NA dataset is representative
merged_data = na.omit(merged_data)
# Add an ID column
merged_data <- merged_data %>% mutate(ID = row_number())
merged_data <- merged_data %>%
mutate(
day = day(birthday),
month = month(birthday),
year = year(birthday)
)
return(merged_data)
}
data = prep_pipeline(data1, data2)
data = prep_pipeline(data1, data2)
